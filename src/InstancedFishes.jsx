/*
Auto-generated by: https://github.com/pmndrs/gltfjsx
*/

import React, { useRef, useMemo, useEffect } from "react";
import { useGLTF } from "@react-three/drei";
import { Euler, InstancedMesh, Matrix4, Vector3 } from "three";
import { randFloatSpread } from "three/src/math/MathUtils";
import { useFrame } from "@react-three/fiber";

export default function Fishes(props) {
  const group = useRef();
  const { nodes, materials } = useGLTF(
    "https://vazxmixjsiawhamofees.supabase.co/storage/v1/object/public/models/fish/model.gltf"
  );
  const fishRef = useRef();
  const defaultMatFishRef = useRef();
  const greyFishRef = useRef();
  const dummy = useMemo(() => new Vector3(), []);
  const fishes = useMemo(() => {
    const temp = [];
    for (let i = 0; i < 1000; i++) {
      const position = new Vector3(
        randFloatSpread(50),
        randFloatSpread(50),
        -randFloatSpread(50) - 25
      );

      const rotation = new Vector3(
        0,
        // position.x > 0 ? Math.PI / 2 : Math.PI / -2,
        Math.random(),
        Math.random()
      );

      temp.push({
        position,
        rotation,
        velocity: Math.random() / 50,
      });
    }
    return temp;
  }, []);

  useEffect(() => {
    fishes.forEach((fish, i) => {
      const positionMatrix = new Matrix4().makeTranslation(
        ...fish.position.toArray()
      );
      const rotationMatrix = new Matrix4().makeRotationFromEuler(
        new Euler(...fish.rotation.toArray())
      );
      const finalMatrix = new Matrix4().multiplyMatrices(
        positionMatrix,
        rotationMatrix
      );
      fishRef.current.setMatrixAt(i, finalMatrix);
      greyFishRef.current.setMatrixAt(i, finalMatrix);
      defaultMatFishRef.current.setMatrixAt(i, finalMatrix);
    });
  }, []);

  useFrame(({ clock }) => {
    for (let i = 0; i < 1000; i++) {
      const fish = fishes[i];
      fish.position.x +=
        Math.sin((i + clock.getElapsedTime()) * 0.5) * fish.velocity;
      fish.position.y +=
        Math.sin((10 + i - clock.getElapsedTime()) * 0.5) * fish.velocity;
      fish.position.z +=
        Math.sin((20 + i + clock.getElapsedTime()) * 0.5) * fish.velocity;

      const positionMatrix = new Matrix4().makeTranslation(
        ...fish.position.toArray()
      );
      const rotationMatrix = new Matrix4().makeRotationFromEuler(
        new Euler(...fish.rotation.toArray())
      );
      const finalMatrix = new Matrix4().multiplyMatrices(
        positionMatrix,
        rotationMatrix
      );
      fishRef.current.setMatrixAt(i, finalMatrix);
      greyFishRef.current.setMatrixAt(i, finalMatrix);
      defaultMatFishRef.current.setMatrixAt(i, finalMatrix);
    }
    fishRef.current.instanceMatrix.needsUpdate = true;
    defaultMatFishRef.current.instanceMatrix.needsUpdate = true;
    greyFishRef.current.instanceMatrix.needsUpdate = true;
  });

  return (
    <group ref={group} {...props}>
      <instancedMesh
        ref={fishRef}
        args={[nodes.Mesh_fish.geometry, materials.pink, 1000]}
      >
        {/* <meshStandardMaterial /> */}
      </instancedMesh>
      <instancedMesh
        ref={greyFishRef}
        args={[nodes.Mesh_fish_1.geometry, materials.greyLight, 1000]}
      >
        {/* <meshStandardMaterial /> */}
      </instancedMesh>
      <instancedMesh
        ref={defaultMatFishRef}
        args={[nodes.Mesh_fish_2.geometry, materials._defaultMat, 1000]}
      >
        {/* <meshStandardMaterial /> */}
      </instancedMesh>
      {/* add instanced meshes for the other meshes */}
      {/* <mesh geometry={nodes.Mesh_fish.geometry} material={materials.pink} />
      <mesh
        geometry={nodes.Mesh_fish_1.geometry}
        material={materials.greyLight}
      />
      <mesh
        geometry={nodes.Mesh_fish_2.geometry}
        material={materials._defaultMat}
      /> */}
    </group>
  );
}

useGLTF.preload(
  "https://vazxmixjsiawhamofees.supabase.co/storage/v1/object/public/models/fish/model.gltf"
);
